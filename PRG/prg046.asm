; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; and THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg015.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Tile_Layout_TS16:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $55, $DC, $FF, $05, $05, $E8, $05, $26, $55, $75, $55, $56, $3E, $2E, $2C, $3C ; Tiles $00 - $0F
	.byte $4C, $FC, $FC, $4E, $70, $42, $33, $FC, $41, $42, $33, $FC, $10, $FD, $14, $62 ; Tiles $10 - $1F
	.byte $51, $6C, $5C, $5E, $6E, $50, $01, $63, $55, $1C, $1E, $0E, $FF, $FF, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $00, $10, $01, $04, $FC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FC, $FC, $05, $05, $FF, $26, $56, $55, $44, $75, $75, $56, $FF, $FC ; Tiles $40 - $4F
	.byte $F4, $F4, $F4, $68, $16, $55, $55, $55, $44, $75, $56, $44, $FF, $FF, $FF, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $98, $98, $98, $98, $A4, $EC, $E4, $C0, $D5, $B2, $E9, $68, $24, $FF ; Tiles $70 - $7F
	.byte $28, $28, $67, $55, $FF, $C4, $50, $26, $61, $15, $06, $55, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $67, $67, $56, $55, $67, $67, $55, $75, $FF, $50, $01, $63, $55, $1C, $1E, $55 ; Tiles $90 - $9F
	.byte $62, $60, $6C, $5C, $5E, $6E, $FF, $FF, $FF, $FF, $47, $30, $30, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $09, $09, $07, $30, $31, $AC, $AE, $B8, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $3E, $2E, $2C, $3C, $4C, $FC, $FC, $4E, $70, $42, $33, $FC, $FC, $26, $3C, $FC ; Tiles $C0 - $CF
	.byte $44, $45, $46, $48, $48, $FF, $CC, $55, $30, $80, $82, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $FE, $01, $3A, $FE, $4A, $6A, $FE, $2B, $51, $6C, $5C, $5E, $6E, $FF ; Tiles $E0 - $EF
	.byte $0E, $D7, $E0, $05, $01, $62, $0A, $66, $01, $62, $FF, $FF, $F1, $48, $F8, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $65, $DD, $FF, $06, $D6, $E9, $14, $36, $45, $65, $65, $66, $FC, $3E, $3C, $FC ; Tiles $00 - $0F
	.byte $5C, $4C, $4E, $5E, $43, $FC, $52, $32, $43, $FC, $31, $32, $20, $21, $21, $72 ; Tiles $10 - $1F
	.byte $61, $65, $6C, $6E, $7E, $60, $03, $73, $1C, $2C, $2E, $1E, $FF, $FF, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $10, $10, $FD, $04, $FC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $FC, $FC, $06, $06, $FF, $36, $74, $45, $66, $65, $45, $66, $FF, $FC ; Tiles $40 - $4F
	.byte $F5, $F5, $F5, $78, $65, $65, $06, $65, $74, $45, $74, $66, $FF, $FF, $FF, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $99, $99, $99, $99, $A5, $ED, $E4, $C1, $B2, $B2, $E8, $78, $34, $FF ; Tiles $70 - $7F
	.byte $28, $38, $65, $77, $FF, $C4, $51, $36, $16, $65, $63, $50, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $66, $65, $77, $77, $45, $65, $77, $77, $FF, $60, $FD, $62, $1C, $2C, $2E, $1E ; Tiles $90 - $9F
	.byte $72, $61, $65, $6C, $6E, $65, $FF, $FF, $FF, $FF, $57, $41, $41, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $19, $19, $17, $40, $41, $AC, $AE, $B9, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $FC, $3E, $3C, $FC, $5C, $4C, $4E, $5E, $43, $FC, $52, $32, $FC, $36, $16, $FC ; Tiles $C0 - $CF
	.byte $44, $45, $48, $48, $4A, $FF, $65, $E6, $32, $90, $92, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $3B, $03, $73, $4A, $2C, $2E, $6A, $FE, $2A, $FE, $6C, $6E, $FE, $FF ; Tiles $E0 - $EF
	.byte $64, $06, $E1, $06, $60, $62, $5A, $66, $60, $62, $FF, $FF, $F0, $58, $F9, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $55, $DE, $FF, $FF, $FF, $EA, $FF, $27, $55, $75, $54, $55, $3F, $2F, $2D, $3D ; Tiles $00 - $0F
	.byte $4D, $FC, $FC, $4F, $43, $73, $FC, $32, $43, $40, $FC, $32, $FD, $12, $14, $52 ; Tiles $10 - $1F
	.byte $61, $6D, $5D, $5F, $6F, $60, $01, $53, $0D, $1D, $1F, $55, $FF, $FF, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $01, $13, $02, $12, $FC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $FF, $FC, $FC, $FF, $FF, $FF, $27, $55, $54, $75, $46, $75, $54, $FF, $37 ; Tiles $40 - $4F
	.byte $F6, $F6, $F6, $69, $55, $15, $55, $55, $75, $46, $54, $46, $FF, $FF, $FF, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $9A, $9A, $9A, $9A, $A6, $EE, $E5, $C2, $D5, $B2, $EB, $69, $25, $FF ; Tiles $70 - $7F
	.byte $29, $29, $55, $77, $FF, $C6, $56, $27, $16, $62, $55, $50, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $55, $54, $77, $77, $55, $75, $77, $77, $FF, $60, $01, $53, $56, $1D, $1F, $56 ; Tiles $90 - $9F
	.byte $63, $61, $6D, $5D, $5F, $6F, $FF, $FF, $FF, $FF, $30, $30, $47, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $0A, $0A, $08, $30, $31, $AD, $AF, $BA, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $3F, $2F, $2D, $3D, $4D, $FC, $FC, $4F, $43, $73, $FC, $32, $3D, $27, $04, $37 ; Tiles $C0 - $CF
	.byte $44, $45, $47, $49, $49, $FF, $CD, $55, $31, $81, $83, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $3B, $01, $FE, $FE, $4B, $6B, $FE, $52, $2A, $6D, $5D, $5F, $6F, $FF ; Tiles $E0 - $EF
	.byte $67, $D7, $E2, $FF, $01, $63, $01, $63, $0B, $0D, $FF, $FF, $F3, $49, $FA, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $65, $DF, $FF, $FF, $D6, $EB, $15, $37, $45, $65, $64, $65, $FC, $3F, $3D, $FC ; Tiles $00 - $0F
	.byte $5D, $4D, $4F, $5F, $FC, $42, $33, $51, $FC, $42, $33, $30, $21, $22, $21, $62 ; Tiles $10 - $1F
	.byte $71, $7D, $6D, $6F, $65, $70, $03, $63, $1D, $2D, $2F, $1F, $FF, $FF, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $BF, $FD, $13, $12, $12, $FC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $FF, $FC, $FC, $FF, $FF, $FF, $37, $45, $76, $65, $64, $45, $64, $FF, $34 ; Tiles $40 - $4F
	.byte $F7, $F7, $F7, $79, $65, $65, $65, $05, $45, $76, $76, $64, $FF, $FF, $FF, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $9B, $9B, $9B, $9B, $A7, $EF, $E5, $C3, $B2, $B2, $EA, $79, $35, $FF ; Tiles $70 - $7F
	.byte $29, $39, $67, $65, $FF, $C6, $57, $37, $65, $15, $06, $60, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $67, $67, $65, $64, $67, $67, $45, $65, $FF, $61, $FD, $63, $1D, $2D, $2F, $1F ; Tiles $90 - $9F
	.byte $62, $71, $66, $6D, $6F, $66, $FF, $FF, $FF, $FF, $41, $41, $57, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $1A, $1A, $18, $40, $41, $AD, $AF, $BB, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $FC, $3F, $3D, $FC, $5D, $4D, $4F, $5F, $FC, $42, $33, $51, $3D, $37, $25, $34 ; Tiles $C0 - $CF
	.byte $44, $45, $49, $49, $4B, $FF, $65, $E7, $33, $91, $93, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $70, $03, $3A, $4B, $2D, $2F, $6B, $2B, $FE, $FE, $6D, $6F, $FE, $FF ; Tiles $E0 - $EF
	.byte $65, $FF, $E3, $FF, $61, $63, $61, $63, $0C, $0D, $FF, $FF, $F2, $59, $FB, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS16:
	.byte $1C, $5F, $99, $E2, $2E, $5F, $A6, $F0 ; $0400 - $0407


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS16
;
; Entry point for loading level layout data for Level_Tileset = 16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS16:

	; Clear Tile memory
	ldy #$00

PRG046_LevelLoad_loop:	 
	lda #TILE16_BG			; Set everything to sewer background
	jsr Tile_Mem_ClearB
	jsr Tile_Mem_ClearA
	cpy #$f0
	bne PRG046_LevelLoad_loop

	jmp LevelLoad			; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS16
;
; Based on the values in var15 and generator_index, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG046_A419:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS16:
	; From level loader function:
	; * var15, var16, and generator_index are three bytes read from the data

	lda <var15
	and #%11100000
	lsr A		
	lsr A		
	lsr A		
	lsr A		
	lsr A		
	tax		 	; X = upper 3 bits of var15 (0-7) (selects a multiple of 15 as the base)

	lda generator_index
	lsr A	
	lsr A	
	lsr A	
	lsr A			; A = upper 4 bits of generator_index shifted down
	add PRG046_A419, x	; add multiple of 15
	tax
	dex
	txa		 ; A = ((generator_index >> 4) + PRG046_A419[X]) - 1


	; Regular Generators
	jsr DynJump

	.word LoadLevel_Sewer_Slope45T2B		;  0 - Above ground (UG only) 45 degree slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2T		;  1 - Above ground (UG only) 45 degree slope bottom-to-top
	.word LoadLevel_Sewer_Slope45T2BCeiling	;  2 - Above ground (UG only) 45 degree ceiling slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2TCeiling	;  3 - Above ground (UG only) 45 degree ceiling slope bottom-to-top
	.word LoadLevel_Sewer_Slope45T2B		;  4 - Underground/Hills normal 45 degree slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2T		;  5 - Underground/Hills normal 45 degree slope bottom-to-top
	.word LoadLevel_Sewer_Slope45T2BCeiling	;  6 - Underground/Hills normal 45 degree ceiling slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2TCeiling	;  7 - Underground/Hills normal 45 degree ceiling slope bottom-to-top
	.word LoadLevel_Sewer_Slope45T2B		;  8 - Underwater 45 degree slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2T		;  9 - Underwater 45 degree slope bottom-to-top
	.word LoadLevel_Sewer_Slope45T2BCeiling	; 10 - Underwater 45 degree ceiling slope top-to-bottom
	.word LoadLevel_Sewer_Slope45B2TCeiling	; 11 - Underwater 45 degree ceiling slope bottom-to-top
	.word $0000		; 12 - Action Switch
	.word $0000		; 13 - Run of the clouds
	.word $0000		; 14 - Same as 9, except underwater ground tiles instead
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word LoadLevel_TopDecoBlocks		; 43 - Top-Deco Rectangle Haunting BG Brick 1
	.word LoadLevel_TopDecoBlocks		; 44 - Top-Deco Rectangle Haunting BG Brick 2
	.word LoadLevel_Slope225T2B		; 45 - Above ground (UG only) 22.5 degree slope top-to-bottom
	.word LoadLevel_Slope225B2T		; 46 - Above ground (UG only) 22.5 degree slope bottom-to-top
	.word LoadLevel_Slope225T2BCeiling	; 47 - Above ground (UG only) 22.5 degree ceiling slope top-to-bottom
	.word LoadLevel_Slope225B2TCeiling	; 47 - Above ground (UG only) 22.5 degree ceiling slope bottom-to-top
	.word LoadLevel_Slope225T2B		; 49 - Underground/Hills normal 22.5 degree slope top-to-bottom
	.word LoadLevel_Slope225B2T		; 50 - Underground/Hills normal 22.5 degree slope bottom-to-top
	.word LoadLevel_Slope225T2BCeiling	; 51 - Underground/Hills normal 22.5 degree ceiling slope top-to-bottom
	.word LoadLevel_Slope225B2TCeiling	; 52 - Underground/Hills normal 22.5 degree ceiling slope bottom-to-top
	.word LoadLevel_Slope225T2B		; 53 - Underwater 22.5 degree slope top-to-bottom
	.word LoadLevel_Slope225B2T		; 54 - Underwater 22.5 degree slope bottom-to-top
	.word LoadLevel_Slope225T2BCeiling	; 55 - Underwater 22.5 degree ceiling slope top-to-bottom
	.word LoadLevel_Slope225B2TCeiling	; 56 - Underwater 22.5 degree ceiling slope bottom-to-top
	.word LoadLevel_Munchers46			; 57 - Run of munchers
	.word LoadLevel_PurpleCoins			; 58 - Run of Purple coins
	.word LoadLevel_PurpleCoinR			; 59 - Rectangle of Purple Coins
	.word LoadLevel_Munchers46_Upsidedown ; 60 - Run of upside down munchers
	.word LevelLoad_OnBlocks46			; 61 - Run of on blocks
	.word LevelLoad_OffBlocks46			; 62 - Run of off blocks
	.word LevelLoad_SwitchUpsideDown46  ; 63 - Run of upside down switches
	.word LevelLoad_CrumblingBlock46	; 64 - Run of crumbling blocks
	.word _apply_sewer_ground_generator	; 65 - Ground for the sewers
	.word _apply_sewer_ceiling_generator	; 66 - Ceiling for the sewers
	.word _apply_sewer_left_wall_generator	; 67 - Left wall for the sewers
	.word _apply_sewer_right_wall_generator	; 68 - Right wall for the sewers
	.word _apply_sewer_wall_generator		; 69 - Wall for sewers
	.word LevelLoad_TopShadow46 	; 70
	.word LevelLoad_BottomShadow46  ; 71
	.word LevelLoad_LeftShadow46	; 72
	.word LevelLoad_RightShadow46	; 73
	.word LevelLoad_Pillar46	; 74 - Pillar for the sewers
	.word LevelLoad_TL_BR_CHAIN46	; 75 Chains from TL to BR
	.word LevelLoad_BL_TR_CHAIN46	; 76 Chains from BL to TR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS16
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS16:
	; It is verified before calling this function that all of
	; the upper 4 bits of generator_index are ZERO

	; So the upper 3 bits of var15 serve as the most significant bits
	; to a value where generator_index provide the 4 least significant bits

	lda <var15
	and #%11100000
	lsr A		
	add generator_index	
	tax		 	; Resultant index is put into 'X'
	jsr DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_Corner46		;  0 - Above Ground upper-left corner tile
	.word LoadLevel_Corner46		;  1 - Underground/Hills normal upper-left corner tile
	.word LoadLevel_Corner46		;  2 - Underwater upper-left corner tile
	.word LoadLevel_Corner46		;  3 - Above Ground upper-right corner tile
	.word LoadLevel_Corner46		;  4 - Underground/Hills normal upper-right corner tile
	.word LoadLevel_Corner46		;  5 - Underwater upper-right corner tile
	.word LoadLevel_Corner46		;  6 - Above Ground lower-left corner tile
	.word LoadLevel_Corner46		;  7 - Underground/Hills normal lower-left corner tile
	.word LoadLevel_Corner46		;  8 - Underwater lower-left corner tile
	.word LoadLevel_Corner46		;  9 - Above Ground lower-right corner tile
	.word LoadLevel_Corner46		; 10 - Underground/Hills normal lower-right corner tile
	.word LoadLevel_Corner46		; 11 - Underwater lower-right corner tile
	.word LoadLevel_StarCoin1		; 12 - Star Coin 1
	.word LoadLevel_StarCoin2		; 13 - Star Coin 2
	.word LoadLevel_StarCoin3		; 14 - Star Coin 3
	.word LoadLevel_Door2			; 15 - Door style 2
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal
	.word LoadLevel_PipeRaiseHelper1	; 42 - Pipe Raise Helper 1
	.word LoadLevel_PipeRaiseHelper2	; 43 - Pipe Raise Helper 2
	.word LoadLevel_PipeRaiseHelper3	; 44 - Pipe Raise Helper 3
	.word LoadLevel_PipeRaiseHelper4	; 45 - Pipe Raise Helper 4
	.word LoadLevel_ActionSwitch		; 46 - Action Switch
	.word $0000
	.word DoubleBlocks				; 48 - Double blocks for the inside of the double wide slopes.
	.word DoubleBlocks
	.word DoubleBlocks
	.word DoubleBlocks


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ActionSwitch46
;
; Places a single corner tile in sewer levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ActionSwitch46: 
	ldy level_data_offset
	lda TILEA_EXSWITCH	 ; Get switch
	sta [level_data_pointer], y	 ; Store into tile mem
	rts


GenerateTopLeftShadingBlocksToChange:
	.byte TILE16_BG

EndGenerateTopLeftShadingBlocksToChange:

GenerateTopLeftShadingBlocksAlternative:
	.byte TILE16_SHADOW_S_BR


GenerateTopRightShadingBlocksToChange:
	.byte TILE16_BG

EndGenerateTopRightShadingBlocksToChange:

GenerateTopRightShadingBlocksAlternative:
	.byte TILE16_SHADOW_S_BL


GenerateBottomLeftShadingBlocksToChange:
	.byte TILE16_BG

EndGenerateBottomLeftShadingBlocksToChange:

GenerateBottomLeftShadingBlksAlternative:
	.byte TILE16_SHADOW_S_TR


GenerateBottomRightShadingBlocksToChange:
	.byte TILE16_BG

EndGenerateBottomRightShadingBlocksToChange:

GenerateBottomRightShadingBlksAlternative:
	.byte TILE16_SHADOW_S_TL


GenerateLeftShadingBlocksToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_S_TR
	.byte TILE16_SHADOW_S_TL
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_BL
	.byte TILE16_SHADOW_TL

EndGenerateLeftShadingBlocksToChange:

GenerateLeftShadingBlocksAlternative:
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_TR
	.byte TILE16_SHADOW_BR
	.byte TILE16_SHADOW_LR
	.byte TILE16_SHADOW_TLR
	.byte TILE16_SHADOW_BLR


GenerateRightShadingBlocksToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_S_TL
	.byte TILE16_SHADOW_S_TR
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_BR
	.byte TILE16_SHADOW_TR

EndGenerateRightShadingBlocksToChange:

GenerateRightShadingBlocksAlternative:
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_TL
	.byte TILE16_SHADOW_BL
	.byte TILE16_SHADOW_LR
	.byte TILE16_SHADOW_TLR
	.byte TILE16_SHADOW_BLR


GenerateTopShadingBlocksToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_S_BL
	.byte TILE16_SHADOW_S_BR
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_BL
	.byte TILE16_SHADOW_BR

EndGenerateTopShadingBlocksToChange:

GenerateTopShadingBlocksAlternative:
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_TB
	.byte TILE16_SHADOW_TR
	.byte TILE16_SHADOW_TL
	.byte TILE16_SHADOW_TBL
	.byte TILE16_SHADOW_TBR


GenerateBottomShadingBlocksToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_TOP
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_TL
	.byte TILE16_SHADOW_TR

EndGenerateBottomShadingBlocksToChange:

GenerateBottomShadingBlocksAlternative:
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_TB
	.byte TILE16_SHADOW_BR
	.byte TILE16_SHADOW_BL
	.byte TILE16_SHADOW_TBL
	.byte TILE16_SHADOW_TBR


LL_Corners46:
	.byte TILE16_GROUNDTL, TILE16_INNER_TL2, TILE16_SLOPE_45_TL	; Upper left
	.byte TILE16_GROUNDTR, TILE16_INNER_TR2, TILE16_SLOPE_45_TR	; Upper right
	.byte TILE16_GROUNDBL, TILE16_INNER_BL2, TILE16_SLOPE_45_BL	; Lower left (not avail AG) 
	.byte TILE16_GROUNDBR, TILE16_INNER_BR2, TILE16_SLOPE_45_BR	; Lower right (not avail AG) 


DoubleBlocks:
	.byte TILE16_INNER_TL, TILE16_INNER_TL+1
	.byte TILE16_INNER_TR, TILE16_INNER_TR+1
	.byte TILE16_INNER_BL, TILE16_INNER_BL+1
	.byte TILE16_INNER_BR, TILE16_INNER_BR+1


LL_SewerInnerGround:	
	.byte TILE16_INNER_GROUND, TILE16_BG, TILE16_INNER_GROUND
LL_SewerMiddleGroundTR:
	.byte TILE16_SLOPE_45_TL, TILE16_SLOPE_45_TL3, TILE16_SLOPE_45_TL2
LL_SewerMiddleGroundTL:
	.byte TILE16_SLOPE_45_TR, TILE16_SLOPE_45_TR3, TILE16_SLOPE_45_TR2
LL_SewerMiddleGroundBR:
	.byte TILE16_SLOPE_45_BL, TILE16_SLOPE_45_BL3, TILE16_SLOPE_45_BL2
LL_SewerMiddleGroundBL:
	.byte TILE16_SLOPE_45_BR, TILE16_SLOPE_45_BR3, TILE16_SLOPE_45_BR2
LL_45SewersT2B:
	.byte TILE14_ABOVE_SLOPE45T2B, TILE3_SLOPE45T2B,  TILE3_WSLOPE45T2B
LL_45SewersB2T:
	.byte TILE14_ABOVE_SLOPE45B2T, TILE3_SLOPE45B2T,  TILE3_WSLOPE45B2T
LL_45SewersT2BCeiling:
	.byte TILE14_ABOVE_S45T2B_CEIL, TILE14_SLOPE45T2B_CEIL, TILE14_WSLOPE45T2B_CEIL
LL_45SewersB2TCeiling:
	.byte TILE14_ABOVE_S45B2T_CEIL, TILE14_SLOPE45B2T_CEIL, TILE14_WSLOPE45B2T_CEIL


_sewer_extended_horizontal_generator_blocks:
	.byte TILE16_GROUNDMM, TILE16_GROUNDMM


; General Methods

;;
; Gets the next char from generator data and increment the pointer to the next index.
;
; Parameters
; ----------
; char: *level_generator_pointer
;     The pointer to the level generator data.
;
; Updates
; -------
; char: *level_generator_pointer
;     The pointer to the level generator data incremented.
;
; Returns
; -------
; char: A
;     The next char of generator data.
;
get_next_char_from_generator_data:
	; Get the next char from the data.
	ldy #$00
	lda [level_generator_pointer], y
	pha

	; Increment level_generator_pointer.
	lda <level_generator_pointer
	add #$01	 
	sta <level_generator_pointer
	lda <level_generator_pointer+1
	adc #$00
	sta <level_generator_pointer+1

	; Restore the the char and return.
	pla
	rts


;;
; Moves the index to the next row.
;
; Parameters
; ----------
; char: *level_data_pointer
;     The pointer to the level data.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data.
;
; Updates
; -------
; char: *level_data_pointer
;     The pointer to the level data moved one below.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data moved one below.
;
; Returns
; -------
; char: Y
;     A copy of `level_data_offset` for easier use.
;
update_level_data_pointer_downwards:
	lda level_data_offset
	add #16
	tay
	sta level_data_offset

	lda <level_data_pointer+1
	adc #$00
	sta <level_data_pointer+1

	rts


;;
; Moves the index to the prior row.
;
; Parameters
; ----------
; char: *level_data_pointer
;     The pointer to the level data.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data.
;
; Updates
; -------
; char: *level_data_pointer
;     The pointer to the level data moved one above.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data moved one above.
;
; Returns
; -------
; char: Y
;     A copy of `level_data_offset` for easier use.
;
update_level_data_pointer_upwards:
	lda level_data_offset
	sub #16
	sta level_data_offset
	tay	

	lda <level_data_pointer+1
	sbc #$00	 
	sta <level_data_pointer+1

	rts


;;
; Moves the index to the next column.
;
; Parameters
; ----------
; char: *level_data_pointer
;     The pointer to the level data.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data.
;
; Updates
; -------
; char: *level_data_pointer
;     The pointer to the level data moved one to the right.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data moved one to the right.
;
; Returns
; -------
; char: Y
;     A copy of `level_data_offset` for easier use.
;
update_level_data_pointer_rightwards:
	ldy level_data_offset
	iny

	; Return if we are on a screen border.
	tya
	and #$0F
	bne Terminate46

	; Go to the next screen by adding 0x01B0 to the index
	lda <level_data_pointer
	add #$B0	 
	sta <level_data_pointer
	lda <level_data_pointer+1
	adc #$01	 
	sta <level_data_pointer+1

	; Get level_data_offset and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	lda level_data_offset
	and #$F0
	tay

Terminate46:
	sty level_data_offset
	rts


;;
; Moves the index to the prior column.
;
; Parameters
; ----------
; char: *level_data_pointer
;     The pointer to the level data.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data.
;
; Updates
; -------
; char: *level_data_pointer
;     The pointer to the level data moved one to the left.
; char: level_data_offset
;     The offset of `level_data_pointer` to the level data moved one to the left.
;
; Returns
; -------
; char: Y
;     A copy of `level_data_offset` for easier use.
;
update_level_data_pointer_leftwards:
	ldy level_data_offset
	dey

	; If we haven't left the left edge of this screen, finish
	tya
	and #$0F
	cmp #$0F
	bne Terminate46

	; Move back one screen by subtracting $1B0 from Map_Tile_Addr
	lda <level_data_pointer
	sub #$B0	 
	sta <level_data_pointer
	lda <level_data_pointer+1
	sbc #$01	 
	sta <level_data_pointer+1

	; Transfer `level_data_offset` to the other side
	iny
	tya
	and #$F0
	ora #$0F
	tay
	sty level_data_offset

	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Corner
;
; Places a single corner tile in sewer levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Corner46:
	ldx generator_index		 ; generator_index is limited 0-15 because of fixed size gen mode, so it's perfect! 
	lda LL_Corners46, x	 ; Get corner tile
	jmp GenerateShading


; Two Block Generator
LoadLevel_DoubleBlock46:
	lda generator_index		; generator_index is limited 0-15 because of fixed size gen mode, so it's perfect! 
	asl A
	tax

	ldy level_data_offset
	lda DoubleBlocks, x	 ; Get first block
	sta [level_data_pointer], y	 ; Store into tile mem
	jsr LoadLevel_NextColumn ; Next column
	inx
	lda DoubleBlocks, x	 ; Get second block
	sta [level_data_pointer], y	 ; Store into tile mem

	rts		 ; Return


GenerateTopLeftShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Move to the top left of the block.
	jsr update_level_data_pointer_leftwards
	jsr update_level_data_pointer_upwards

	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_S_BR
	beq GenerateTopLeftShadingLoopFinish

	; Store it to speed up cycles
	sta <var6

	ldx #(EndGenerateTopLeftShadingBlocksToChange - GenerateTopLeftShadingBlocksToChange)

GenerateTopLeftShadingLoop:
		lda <var6
		cmp GenerateTopLeftShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateTopLeftShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateTopLeftShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateTopLeftShadingLoopFinish

	; Continue looping while X >= 0
GenerateTopLeftShadingLoopContinue:
		dex

	bpl GenerateTopLeftShadingLoop	 	

GenerateTopLeftShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


GenerateTopRightShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	jsr update_level_data_pointer_rightwards	; Get to the right column index.
	jsr update_level_data_pointer_upwards

	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_S_BL
	beq GenerateTopRightShadingLoopFinish

	; Store it to speed up cycles
	sta <var6

	ldx #(EndGenerateTopRightShadingBlocksToChange - GenerateTopRightShadingBlocksToChange)

GenerateTopRightShadingLoop:
		lda <var6
		cmp GenerateTopLeftShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateTopRightShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateTopRightShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateTopRightShadingLoopFinish

	; Continue looping while X >= 0
GenerateTopRightShadingLoopContinue:
		dex

	bpl GenerateTopRightShadingLoop	 	

GenerateTopRightShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


GenerateBottomLeftShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	jsr update_level_data_pointer_leftwards	; Get to the left column index.
	jsr update_level_data_pointer_downwards

	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_S_TR
	beq GenerateBottomLeftShadingLoopFinish

	; Store it to speed up cycles
	sta <var6

	ldx #(EndGenerateBottomLeftShadingBlocksToChange - GenerateBottomLeftShadingBlocksToChange)

GenerateBottomLeftShadingLoop:
		lda <var6
		cmp GenerateBottomLeftShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateBottomLeftShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateBottomLeftShadingBlksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateBottomLeftShadingLoopFinish

	; Continue looping while X >= 0
GenerateBottomLeftShadingLoopContinue:
		dex

	bpl GenerateBottomLeftShadingLoop	 	

GenerateBottomLeftShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


GenerateBottomRightShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	jsr update_level_data_pointer_rightwards	; Get to the right column index.
	jsr update_level_data_pointer_downwards

	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_S_TL
	beq GenerateBottomRightShadingLoopFinish

	; Store it to speed up cycles
	sta <var6

	ldx #(EndGenerateBottomRightShadingBlocksToChange - GenerateBottomRightShadingBlocksToChange)

GenerateBottomRightShadingLoop:
		lda <var6
		cmp GenerateBottomRightShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateBottomRightShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateBottomRightShadingBlksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateBottomRightShadingLoopFinish

	; Continue looping while X >= 0
GenerateBottomRightShadingLoopContinue:
		dex

	bpl GenerateBottomRightShadingLoop	 	

GenerateBottomRightShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


GenerateBottomShading:
	jsr update_level_data_pointer_downwards  ; Get the block one below the current block

	ldx #(EndGenerateBottomShadingBlocksToChange - GenerateBottomShadingBlocksToChange)

GenerateBottomShadingLoop:
		lda [level_data_pointer], Y
		cmp GenerateBottomShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateBottomShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateBottomShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateBottomShadingLoopFinish

	; Continue looping while X >= 0
GenerateBottomShadingLoopContinue:
		dex

	bpl GenerateBottomShadingLoop	 	

GenerateBottomShadingLoopFinish:
	jmp update_level_data_pointer_upwards	; Restore the column index.


GenerateTopShading:
	jsr update_level_data_pointer_upwards	; Get the block one above the current block

	ldx #(EndGenerateTopShadingBlocksToChange - GenerateTopShadingBlocksToChange)

GenerateTopShadingLoop:
		lda [level_data_pointer], Y
		cmp GenerateTopShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateTopShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateTopShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateTopShadingLoopFinish

	; Continue looping while X >= 0
GenerateTopShadingLoopContinue:
		dex

	bpl GenerateTopShadingLoop	 	

GenerateTopShadingLoopFinish:
	jmp update_level_data_pointer_downwards	; Restore the column index.


GenerateLeftShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	jsr update_level_data_pointer_leftwards	; Get to the left column index.

	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_LEFT
	beq GenerateLeftShadingLoopFinish

	; Store it to speed up cycles
	sta <var6

	ldx #(EndGenerateLeftShadingBlocksToChange - GenerateLeftShadingBlocksToChange)

GenerateLeftShadingLoop:
		lda <var6
		cmp GenerateLeftShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateLeftShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateLeftShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateLeftShadingLoopFinish

	; Continue looping while X >= 0
GenerateLeftShadingLoopContinue:
		dex

	bpl GenerateLeftShadingLoop	 	

GenerateLeftShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts
	

GenerateRightShading:
	; Save offset
	lda level_data_offset
	pha

	; Save Address to contain issues.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	jsr update_level_data_pointer_rightwards	; Get to the right column index.
	
	; If we already have a shadow, do nothing
	lda [level_data_pointer], Y
	cmp #TILE16_SHADOW_RIGHT
	beq GenerateRightShadingLoopFinish

	; Store it to speed up cycles
	sta <var6
	
	ldx #(EndGenerateRightShadingBlocksToChange - GenerateRightShadingBlocksToChange)

GenerateRightShadingLoop:
		lda <var6
		cmp GenerateRightShadingBlocksToChange, X
		
		; If the not block equal, continue looping...
		bne GenerateRightShadingLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda GenerateRightShadingBlocksAlternative, X
			sta [level_data_pointer], Y
			jmp GenerateRightShadingLoopFinish

	; Continue looping while X >= 0
GenerateRightShadingLoopContinue:
		dex

	bpl GenerateRightShadingLoop	 	

GenerateRightShadingLoopFinish:
	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_Pillar46
;
; Creates a pillar.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_Pillar46:
	lda #$00
	beq LevelLoad_TopMiddleBottomVerticle


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TopMiddleBottomVerticle
;
; Loads a top, middle, and bottom for a vertical block.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TopMiddleBottomBlocks:
	.byte TILE16_PILLAR_T, TILE16_PILLAR_M, TILE16_PILLAR_B, $00
	.byte $00, $00, $00, $00


; Vertical Top Middle Bottom Block Run
LevelLoad_TopMiddleBottomVerticle:
	asl A
	asl A
	tax				; The provided index * 4 will become the index into the blocks
	STX <var10

	; Get the low block index
	ldy level_data_offset

	; Place the top block and generate shading for pillar
	lda TopMiddleBottomBlocks, X
	jsr GenerateShading

	; Get ready to place middle block
	jsr update_level_data_pointer_downwards
	inc <var10

	; Find the size 1-16 of the block run
	lda generator_index
	and #$0f	 
	sta <var11	

	; Place middle block 1-16 times.
	TopMiddleBottomVerticle_PlaceMiddleBlock46:
		; Place middle block and generate shading for pillar
		ldx <var10
		lda TopMiddleBottomBlocks, X
		jsr GenerateShading

		jsr update_level_data_pointer_downwards

		dec <var11
	bpl TopMiddleBottomVerticle_PlaceMiddleBlock46	 	
	
	; Get ready to place bottom block
	inc <var10

	; Place bottom block and generate shading for pillar
	ldx <var10
	lda TopMiddleBottomBlocks, X
	jsr GenerateShading
	
	rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TopShadow46
;
; Puts down 1-16 top shadows
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TopShadow46:
	lda #TILE16_SHADOW_TOP
	bne LLM46_SeTTile


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_BottomShadow46
;
; Puts down 1-16 bottom shadows
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_BottomShadow46:
	lda #TILE16_SHADOW_BTM
	bne LLM46_SeTTile


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Ground
;
; Puts down 1-16 ground
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_ground_generator:
	lda #TILE16_GROUNDTM
	jmp LLM46_SeTTile_WithTopShadow


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Ceiling
;
; Puts down 1-16 ceiling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_ceiling_generator:
	lda #TILE16_GROUNDBM
	jmp LLM46_SeTTile_WithBottomShadow


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Munchers
;
; Puts down 1-16 munchers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Munchers46:
	lda #TILEA_MUNCHER
	bne LLM46_SeTTile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Munchers15_Upsidedown
;
; Puts down 1-16 munchers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Munchers46_Upsidedown:
	lda #TILEA_UPSIDEDOWN_MUNCHER
	bne LLM46_SeTTile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_OnBlocks46
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_OnBlocks46:
	lda #TILEA_ON_BLOCK
	bne LLM46_SeTTile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_OffBlocks46
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_OffBlocks46:
	lda #TILEA_OFF_BLOCK
	bne LLM46_SeTTile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_SwitchUpsideDown46
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_SwitchUpsideDown46:
	lda #TILEA_EXSWITCHR
	bne LLM46_SeTTile


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_SwitchUpsideDown46
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_CrumblingBlock46:
	lda #TILEA_CRUMBLINGBLOCK
	bne LLM46_SeTTile

; Horizontal Block Run
LLM46_SeTTile:
	sta <var5

	lda generator_index	
	and #$0f	
	tax		 ; var4 = lower 4 bits of generator_index
	ldy level_data_offset	 ; Y = level_data_offset

PRG046_A6DD:
	lda <var5
	sta [level_data_pointer], y	 ; Store into tile mem
	jsr LoadLevel_NextColumn ; Next column
	dex		 	 ; X--
	bpl PRG046_A6DD	 	 ; While X >= 0, loop!

	rts		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LLM46_SeTTile_WithShadow
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLM46_SeTTile_WithShadow:
	sta <var5

	lda generator_index	
	and #$0f	
	tax		 ; var4 = lower 4 bits of generator_index
	ldy level_data_offset	 ; Y = level_data_offset

PRG046_A6DF:
	txa
	pha
	lda <var5
	sta [level_data_pointer], y	 ; Store into tile mem
	pla
	tax

	jsr GenerateShading

	jsr LoadLevel_NextColumn ; Next column
	dex		 	 ; X--
	bpl PRG046_A6DF	 	 ; While X >= 0, loop!

	rts		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LLM46_SeTTile_WithTopShadow
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLM46_SeTTile_WithTopShadow:
	sta <var5

	lda generator_index	
	and #$0f	
	tax		 ; var4 = lower 4 bits of generator_index
	ldy level_data_offset	 ; Y = level_data_offset

PRG046_A6E0:
	txa
	pha
	jsr GenerateTopShading
	pla
	tax

	lda <var5
	sta [level_data_pointer], y	 ; Store into tile mem

	jsr LoadLevel_NextColumn ; Next column
	dex		 	 ; X--
	bpl PRG046_A6E0	 	 ; While X >= 0, loop!

	rts		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LLM46_SeTTile_WithBottomShadow
;
; Puts down 1-16 on blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLM46_SeTTile_WithBottomShadow:
	sta <var5

	lda generator_index	
	and #$0f	
	tax		 ; var4 = lower 4 bits of generator_index
	ldy level_data_offset	 ; Y = level_data_offset

PRG046_A6E1:
	txa
	pha
	jsr GenerateBottomShading
	pla
	tax

	lda <var5
	sta [level_data_pointer], y	 ; Store into tile mem

	jsr LoadLevel_NextColumn ; Next column
	dex		 	 ; X--
	bpl PRG046_A6E1	 	 ; While X >= 0, loop!

	rts		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_LeftShadow46
;
; Puts down 1-16 left shadows
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_LeftShadow46:
	lda #TILE16_SHADOW_LEFT
	bne LLM46_SeTTileV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_RightShadow46
;
; Puts down 1-16 left walls
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_RightShadow46:
	lda #TILE16_SHADOW_RIGHT


; Vertical Block Run
LLM46_SeTTileV:
	sta <var5

	lda generator_index
	pha	 			 ; Save generator_index
	and #$0f	 
	sta <var1	 ; var1 = lower 4 bits of generator_index
	pla				 ; Restore generator_index
	
	ldy level_data_offset 	; Y = level_data_offset

; Loop through the number of times defined by var1 placing var5 into level memory vertically.
PRG046_D811:
	; Store into tile mem
	lda <var5
	sta [level_data_pointer], y	 

	jsr update_level_data_pointer_downwards

	; While var1 >= 0, loop!
	dec <var1
	bpl PRG046_D811	 	
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TL_BR_CHAIN46
;
; Puts down 1-16 chains from top left to bottom right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TL_BR_CHAIN46ToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_TOP

EndLevelLoad_TL_BR_CHAIN46:

LevelLoad_TL_BR_CHAIN46Alternative:
	.byte TILE16_TL_BR_CHAIN
	.byte TILE16_TL_BR_BL_CHAIN
	.byte TILE16_TL_BR_TR_CHAIN
	.byte TILE16_TL_BR_TR_CHAIN2
	.byte TILE16_TL_BR_BL_CHAIN2

LevelLoad_TL_BR_CHAIN46:
	lda generator_index
	pha	 			 ; Save generator_index
	and #$0f	 
	sta <var1	 ; var1 = lower 4 bits of generator_index
	pla				 ; Restore generator_index
	
	ldy level_data_offset 	; Y = level_data_offset

; Loop through the number of times defined by var1 placing var5 into level memory vertically.
Loop_LLM46_SeTTileTL_BR:
	; Store into tile mem

	lda [level_data_pointer], y	 
	ldx #(EndLevelLoad_TL_BR_CHAIN46 - LevelLoad_TL_BR_CHAIN46ToChange)

Loop_LLM46_SeTTileTL_BRLoop:
		lda [level_data_pointer], Y
		cmp LevelLoad_TL_BR_CHAIN46ToChange, X
		
		; If the not block equal, continue looping...
		bne LLM46_SeTTileTL_BRLoopLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda LevelLoad_TL_BR_CHAIN46Alternative, X
			sta [level_data_pointer], Y
			jmp LLM46_SeTTileTL_BRLoopLoopFinish

	; Continue looping while X >= 0
LLM46_SeTTileTL_BRLoopLoopContinue:
		dex

	bpl Loop_LLM46_SeTTileTL_BRLoop
	lda TILE16_TL_BR_CHAIN
	sta [level_data_pointer], y	 

LLM46_SeTTileTL_BRLoopLoopFinish:
	jsr update_level_data_pointer_downwards
	jsr update_level_data_pointer_rightwards

	; While var1 >= 0, loop!
	dec <var1
	bpl Loop_LLM46_SeTTileTL_BR	 	
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TL_BR_CHAIN46
;
; Puts down 1-16 chains from top left to bottom right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_BL_TR_CHAIN46ToChange:
	.byte TILE16_BG
	.byte TILE16_SHADOW_RIGHT
	.byte TILE16_SHADOW_LEFT
	.byte TILE16_SHADOW_BTM
	.byte TILE16_SHADOW_TOP

EndLevelLoad_BL_TR_CHAIN46:

LevelLoad_BL_TR_CHAIN46Alternative:
	.byte TILE16_BL_TR_CHAIN
	.byte TILE16_BR_TL_TL_CHAIN
	.byte TILE16_BR_TL_BR_CHAIN  
	.byte TILE16_BR_TL_BR_CHAIN2
	.byte TILE16_BR_TL_TL_CHAIN2

LevelLoad_BL_TR_CHAIN46:
	lda generator_index
	pha	 			 ; Save generator_index
	and #$0f	 
	sta <var1	 ; var1 = lower 4 bits of generator_index
	pla				 ; Restore generator_index
	
	ldy level_data_offset 	; Y = level_data_offset

; Loop through the number of times defined by var1 placing var5 into level memory vertically.
Loop_LLM46_SeTTileBL_TR:
	lda [level_data_pointer], y	 
	ldx #(EndLevelLoad_BL_TR_CHAIN46 - LevelLoad_BL_TR_CHAIN46ToChange)

Loop_LLM46_SeTTileBL_TRLoop:
		lda [level_data_pointer], Y
		cmp LevelLoad_BL_TR_CHAIN46ToChange, X
		
		; If the not block equal, continue looping...
		bne LLM46_SeTTileBL_TRLoopLoopContinue

			; Apply the alternative block to index and jump out of this method.
			lda LevelLoad_BL_TR_CHAIN46Alternative, X
			sta [level_data_pointer], Y
			jmp LLM46_SeTTileBL_TRLoopLoopFinish

	; Continue looping while X >= 0
LLM46_SeTTileBL_TRLoopLoopContinue:
		dex

	bpl Loop_LLM46_SeTTileBL_TRLoop
	lda TILE16_BL_TR_CHAIN
	sta [level_data_pointer], y	 

LLM46_SeTTileBL_TRLoopLoopFinish:

	jsr update_level_data_pointer_upwards
	jsr update_level_data_pointer_rightwards

	; While var1 >= 0, loop!
	dec <var1
	bpl Loop_LLM46_SeTTileBL_TR 	
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Wall
;
; Puts down 1-256 wall blocks, up to 16 tiles tall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_wall_generator:
	lda #$01	 ; X = 1 (bright diamond blocks)
	bne _apply_sewer_extended_horizontal_generator

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; _apply_sewer_solid_bricks
;
; Puts down 1-256 solid bricks, up to 16 tiles tall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_solid_bricks:
	lda #$00	 ; X = 0 (solid brick)


;;
;
;
_apply_sewer_extended_horizontal_generator:
	; Move the accomulator to the X register
	tax

	; Save offset
	lda level_data_offset
	pha

	; Save address.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Save parent variables
	lda <var10
	pha
	lda <var11
	pha
	lda <var12
	pha
	lda <var13
	pha
	lda <var14
	pha
	lda <var15
	pha

	; Get the horizontal size of the generator.
	jsr get_next_char_from_generator_data
	sta <var10
	inc <var10  ; Makes looping nicer

	; Determine the height of the slope.
	lda generator_index
	and #$0F
	sta <var11

	; Counter of the number of the inner blocks to create.
	sta <var12
	inc <var12  ; Makes looping nicer

_loop_horizontal_sewer_extended_horizontal_generator:
	; Save offset and address for looping.
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

_loop_vertical_sewer_extended_horizontal_generator:
	lda _sewer_extended_horizontal_generator_blocks, x
	sta [level_data_pointer], y

	jsr update_level_data_pointer_downwards

	dec <var12
	bne _loop_vertical_sewer_extended_horizontal_generator

	; Reset the counter for the next row.
	lda <var11
	sta <var12
	inc <var12  ; Makes looping nicer

	; Restore offset and address for looping.
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	jsr update_level_data_pointer_rightwards

	; Check if we have more blocks to place horizontally.
	dec <var10
	beq _finished_loop_vertical_sewer_extended_horizontal_generator

	jmp _loop_horizontal_sewer_extended_horizontal_generator

_finished_loop_vertical_sewer_extended_horizontal_generator:
	; Restore parent variables
	pla
	sta <var15
	pla
	sta <var14
	pla
	sta <var13
	pla
	sta <var12
	pla
	sta <var11
	pla
	sta <var10

	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; _apply_sewer_left_wall_generator
;
; Puts down 1-16 left walls
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_left_wall_generator:
	lda #TILE16_GROUNDML


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LLM46_SeTTileV_LeftShadow
;
; Puts down 1-16 blocks with shadow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLM46_SeTTileV_LeftShadow:
	sta <var10

	lda generator_index
	pha	 			 ; Save generator_index
	and #$0f	 
	sta <var11	 ; var11 = lower 4 bits of generator_index
	pla				 ; Restore generator_index
	
	ldy level_data_offset 	; Y = level_data_offset

; Loop through the number of times defined by var11 placing var10 into level memory vertically.
PRG046_D812:
	jsr GenerateLeftShading

	; Store into tile mem
	ldy level_data_offset
	lda <var10
	sta [level_data_pointer], y	 

	jsr update_level_data_pointer_downwards

	; While var11 >= 0, loop!
	dec <var11
	bpl PRG046_D812 	
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; _apply_sewer_right_wall_generator
;
; Puts down 1-16 right walls
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_apply_sewer_right_wall_generator:
	lda #TILE16_GROUNDMR


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LLM46_SeTTileV_RightShadow
;
; Puts down 1-16 blocks with shadow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLM46_SeTTileV_RightShadow:
	sta <var10

	lda generator_index
	pha	 			 ; Save generator_index
	and #$0f	 
	sta <var11	 ; var1 = lower 4 bits of generator_index
	pla				 ; Restore generator_index
	
	ldy level_data_offset 	; Y = level_data_offset

; Loop through the number of times defined by var1 placing var10 into level memory vertically.
LLM46_SeTTileV_RightShadow_Loop:
	jsr GenerateRightShading

	; Store into tile mem
	ldy level_data_offset
	lda <var10
	sta [level_data_pointer], y	 

	jsr update_level_data_pointer_downwards

	; While var1 >= 0, loop!
	dec <var11
	bpl LLM46_SeTTileV_RightShadow_Loop	
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GenerateShading
;
; Generates shading for the sewer tileset.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GenerateShading:
	; Store the block into memory
	ldy level_data_offset
	sta [level_data_pointer], y	 

	ldy level_data_offset
	jsr GenerateRightShading

	ldy level_data_offset
	jsr GenerateLeftShading

	ldy level_data_offset
	jsr GenerateTopShading
	
	ldy level_data_offset
	jsr GenerateBottomShading

	ldy level_data_offset
	jsr GenerateTopLeftShading

	ldy level_data_offset
	jsr GenerateTopRightShading

	ldy level_data_offset
	jsr GenerateBottomLeftShading

	ldy level_data_offset
	jsr GenerateBottomRightShading

	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Sewer_Slope45T2B
;
; Adds a 1-16 length 45 degree top-to-bottom slope.  With each
; iteration, it adds one more "midground" tile to the left of the
; slope.  So it looks like this:
; \
; S\
; MS\
; MMS\
;    S
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LoadLevel_Sewer_Slope45T2B:	
	; Save offset
	lda level_data_offset
	pha

	; Save address.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Save parent variables
	lda <var10
	pha
	lda <var11
	pha
	lda <var12
	pha
	lda <var13
	pha
	lda <var14
	pha
	lda <var15
	pha
	lda <var16
	pha

	; Counter of the number of inner and middle grounds to place at the current location.
	lda #$00
	sta <var10
	sta <var16

	; Determine the size of the slope.
	lda generator_index
	and #$0F
	sta <var11

	; Find the relative index of the slope.
	lda generator_index	 
	sub #$10
	and #$c0
	clc	
	rol A	
	rol A	
	rol A
	sta <var12

Sewer_Slope45T2B_LoopRow:
	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

Sewer_Slope45T2B_LoopInnerGround:
	; Escape out of loop when one or less.
	lda <var10
	cmp #$01
	bcc Sewer_Slope45T2B_FinishedLoopInnerGround
	beq Sewer_Slope45T2B_FinishedLoopInnerGround
	
	; Place the inner ground.
	ldx <var12
	lda LL_SewerInnerGround, x
	sta [level_data_pointer], y

	; Move to the right one.
	jsr update_level_data_pointer_rightwards

	dec <var10
	jmp Sewer_Slope45T2B_LoopInnerGround

Sewer_Slope45T2B_FinishedLoopInnerGround:
	; If at the top of the slope, do not place middle ground
	lda <var10
	beq Sewer_Slope45T2B_PlaceSlope

	; add the middle ground
	ldx <var12
	lda LL_SewerMiddleGroundTL, X
	sta [level_data_pointer], y	 ; Store into tile mem
	
	; Move to the right one.
	jsr update_level_data_pointer_rightwards

Sewer_Slope45T2B_PlaceSlope:
	; Place a slope block.
	ldx <var12
	lda LL_45SewersT2B, x
	sta [level_data_pointer], y

	; Generate right shading.
	jsr update_level_data_pointer_leftwards
	jsr GenerateTopRightShading

	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Go down one block.
	jsr update_level_data_pointer_downwards

	; Each row is one larger.
	inc <var16
	lda <var16
	sta <var10

	; Determine if we should continue making a slope.
	dec <var11
	bne Sewer_Slope45T2B_LoopRow

; Move to the right of the slope.
Sewer_Slope45T2B_PlaceLowerMiddleGround:
	lda <var10
	cmp #$01
	bcc Sewer_Slope45T2B_FinishedPlaceLowerMiddleGround
	beq Sewer_Slope45T2B_FinishedPlaceLowerMiddleGround

	jsr update_level_data_pointer_rightwards

	dec <var10
	jmp Sewer_Slope45T2B_PlaceLowerMiddleGround

Sewer_Slope45T2B_FinishedPlaceLowerMiddleGround
	; Place the lower inner slope
	ldx <var12
	lda LL_SewerMiddleGroundTL, x
	sta [level_data_pointer], y

	jmp Sewer_Slope_Finish


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Sewer_Slope45B2T
;
; Adds a 1-16 length 45 degree bottom-to-top slope.  With each
; iteration, it adds one more "midground" tile to the right of
; the slope.  So it looks like this:
;    /
;   /S
;  /SM
; /SMM
; S
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Sewer_Slope45B2T:
	; Save offset
	lda level_data_offset
	pha

	; Save address.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Save parent variables
	lda <var10
	pha
	lda <var11
	pha
	lda <var12
	pha
	lda <var13
	pha
	lda <var14
	pha
	lda <var15
	pha
	lda <var16
	pha

	; Counter of the number of inner and middle grounds to place at the current location.
	lda #$00
	sta <var10
	sta <var16

	; Determine the size of the slope.
	lda generator_index
	and #$0F
	sta <var11
	inc <var11  ; Makes looping easier

	; Find the relative index of the slope.
	lda generator_index	 
	sub #$10
	and #$c0
	clc	
	rol A	
	rol A	
	rol A
	sta <var12

Sewer_Slope45B2T_LoopRow:
	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

	; Generate the shading for the current slope
	jsr update_level_data_pointer_rightwards
	jsr GenerateTopLeftShading

	; Restore the offset and address
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Place a slope block.
	ldx <var12
	lda LL_45SewersB2T, x
	sta [level_data_pointer], y

	; Jump if there are no blocks to place.
	lda <var10
	beq Sewer_Slope45B2T_FinishMiddleGround
	
	; Move to the right one
	jsr update_level_data_pointer_rightwards

	; Place the middle ground
	ldx <var12
	lda LL_SewerMiddleGroundTR, X
	sta [level_data_pointer], y	 ; Store into tile mem
	
	; Jump if there are no blocks to place.
	dec <var10
	beq Sewer_Slope45B2T_FinishMiddleGround

Sewer_Slope45B2T_LoopInnerGround:
	; Move to the right one
	jsr update_level_data_pointer_rightwards
	
	ldx <var12
	lda LL_SewerInnerGround, x	 ; Get mid-ground tile
	sta [level_data_pointer], y	 ; Store into tile mem

	; Jump if there are no blocks to place.
	dec <var10
	bne Sewer_Slope45B2T_LoopInnerGround

Sewer_Slope45B2T_FinishMiddleGround:

	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Go back one block and down one.
	jsr update_level_data_pointer_leftwards
	jsr update_level_data_pointer_downwards

	; Each row is one larger.
	inc <var16
	lda <var16
	sta <var10

	; Determine if we should continue making a slope.
	dec <var11
	bne Sewer_Slope45B2T_LoopRow

	; Place the lower inner slope
	jsr update_level_data_pointer_rightwards

	ldx <var12
	lda LL_SewerMiddleGroundTR, x
	sta [level_data_pointer], y

	jmp Sewer_Slope_Finish


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Sewer_Slope45T2BCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; S
; \SMM
;  \SM
;   \S
;    \
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Sewer_Slope45T2BCeiling:
	; Save offset
	lda level_data_offset
	pha

	; Save address.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Save parent variables
	lda <var10
	pha
	lda <var11
	pha
	lda <var12
	pha
	lda <var13
	pha
	lda <var14
	pha
	lda <var15
	pha
	lda <var16
	pha

	; Determine the size of the slope.
	lda generator_index
	and #$0F
	sta <var11
	inc <var11  ; Makes looping easier

	; Counter of the number of inner and middle grounds to place at the current location.
	sta <var10
	sta <var16

	; Find the relative index of the slope.
	lda generator_index	 
	sub #$10
	and #$c0
	clc	
	rol A	
	rol A	
	rol A
	sta <var12

	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

	; Place the middle ground one above the start of the slope.
	jsr update_level_data_pointer_upwards

	ldx <var12
	lda LL_SewerMiddleGroundBR, x
	sta [level_data_pointer], y

Sewer_Slope45T2BCeiling_LoopRow:
	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

	; Place a slope block.
	ldx <var12
	lda LL_45SewersT2BCeiling, x
	sta [level_data_pointer], y

	; Generate right shading.
	jsr update_level_data_pointer_rightwards
	jsr GenerateBottomLeftShading

	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Jump if there are no blocks to place.
	lda <var10
	beq Sewer_Slope45T2BC_FinishMiddleGround
	
	; Move to the right one
	jsr update_level_data_pointer_rightwards

	; Place the middle ground
	ldx <var12
	lda LL_SewerMiddleGroundBR, X
	sta [level_data_pointer], y
	
	; Jump if there are no blocks to place.
	dec <var10
	beq Sewer_Slope45T2BC_FinishMiddleGround

Sewer_Slope45T2BC_LoopInnerGround:
	; Move to the right one.
	jsr update_level_data_pointer_rightwards
	
	; Place the inner ground.
	ldx <var12
	lda LL_SewerInnerGround, x
	sta [level_data_pointer], y

	; Jump if there are no blocks to place.
	dec <var10
	bne Sewer_Slope45T2BC_LoopInnerGround

Sewer_Slope45T2BC_FinishMiddleGround:
	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Go down one block and right one.
	jsr update_level_data_pointer_rightwards
	jsr update_level_data_pointer_downwards

	; Each row is one smaller.
	dec <var16
	lda <var16
	sta <var10

	; Determine if we should continue making a slope.
	dec <var11
	bne Sewer_Slope45T2BCeiling_LoopRow

	jmp Sewer_Slope_Finish


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Sewer_Slope45B2TCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
;    S
; MMS/
; MS/ 
; S/  
; /   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Sewer_Slope45B2TCeiling:
	; Save offset
	lda level_data_offset
	pha

	; Save address.
	lda <level_data_pointer
	pha
	lda <level_data_pointer+1
	pha

	; Save parent variables
	lda <var10
	pha
	lda <var11
	pha
	lda <var12
	pha
	lda <var13
	pha
	lda <var14
	pha
	lda <var15
	pha
	lda <var16
	pha

	; Determine the size of the slope.
	lda generator_index
	and #$0F
	sta <var11
	inc <var11  ; Makes looping easier

	; Counter of the number of inner and middle grounds to place at the current location.
	sta <var10
	sta <var16

	; Find the relative index of the slope.
	lda generator_index	 
	sub #$10
	and #$c0
	clc	
	rol A	
	rol A	
	rol A
	sta <var12

	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

	; Place the middle ground one above the start of the slope.
	jsr update_level_data_pointer_upwards

	; Skip moving to the right if first slope.
	lda <var10
	beq Sewer_Slope45B2TCeiling_FinishedFirstMiddle

; Must get all the way to the right.
Sewer_Slope45B2TCeiling_FirstMiddleLoop
	jsr update_level_data_pointer_rightwards

	dec <var10
	bne Sewer_Slope45B2TCeiling_FirstMiddleLoop

Sewer_Slope45B2TCeiling_FinishedFirstMiddle
	; Reset the counter.
	lda <var16
	sta <var10

	; Place the middle ground.
	ldx <var12
	lda LL_SewerMiddleGroundBL, x
	sta [level_data_pointer], y

	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

Sewer_Slope45B2TCeiling_LoopRow:
	; Save offset and address for looping
	lda level_data_offset
	tay
	sta <var13
	lda <level_data_pointer
	sta <var14
	lda <level_data_pointer+1
	sta <var15

Sewer_Slope45T2BCeiling_LoopInnerGround:
	; Escape out of loop when one or less.
	lda <var10
	cmp #$01
	bcc Sewer_Slope45T2BCeiling_FinishedLoopInnerGround
	beq Sewer_Slope45T2BCeiling_FinishedLoopInnerGround
	
	; Place the inner ground.
	ldx <var12
	lda LL_SewerInnerGround, x
	sta [level_data_pointer], y

	; Move to the right one.
	jsr update_level_data_pointer_rightwards

	dec <var10
	jmp Sewer_Slope45T2BCeiling_LoopInnerGround

Sewer_Slope45T2BCeiling_FinishedLoopInnerGround:
	; If at the top of the slope, do not place middle ground
	lda <var10
	beq Sewer_Slope45T2BCeiling_PlaceSlope

	; add the middle ground
	ldx <var12
	lda LL_SewerMiddleGroundBL, X
	sta [level_data_pointer], y	 ; Store into tile mem
	
	; Move to the right one.
	jsr update_level_data_pointer_rightwards

Sewer_Slope45T2BCeiling_PlaceSlope:
	; Place a slope block.
	ldx <var12
	lda LL_45SewersB2TCeiling, x
	sta [level_data_pointer], y

	; Generate right shading.
	jsr update_level_data_pointer_leftwards
	jsr GenerateBottomRightShading

	; Restore offset and address for looping
	lda <var13
	tay
	sta level_data_offset
	lda <var14
	sta <level_data_pointer
	lda <var15
	sta <level_data_pointer+1

	; Go down one block.
	jsr update_level_data_pointer_downwards

	; Each row is one smaller.
	dec <var16
	lda <var16
	sta <var10

	; Determine if we should continue making a slope.
	dec <var11
	bne Sewer_Slope45B2TCeiling_LoopRow


Sewer_Slope_Finish:
	; Restore parent variables
	pla
	sta <var16
	pla
	sta <var15
	pla
	sta <var14
	pla
	sta <var13
	pla
	sta <var12
	pla
	sta <var11
	pla
	sta <var10

	; Restore address
	pla
	sta <level_data_pointer+1
	pla
	sta <level_data_pointer

	; Restore offset
	pla
	sta level_data_offset
	rts


	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Sewers.asm"
